<!doctype html>
<html>
<head>
<meta charset="UTF-8">
<title>Untitled Document</title>
</head>

<body>

<script>

var BlockType = {
  UNKNOWN: 0,
  DEFINE: 1,
  BUILTINBIN: 2,
  BUILTININF: 3
};

var ProgressStage = {
  OPENBRACKET: 0,
  OPERATOR: 1,
  IDENTIFIER: 2,
  ARGUMENT: 3,
  CLOSEBRACKET: 4,
  CLEANUP: 5
}

var rString = "(define x 4)";


var definitions = {};
var builtInFuncInf = ["+", "-", "/", "*"];
var builtInFuncBin = ["remainder", "quotient"];


function process(block) {
  
  var thisBlockType = BlockType.UNKNOWN;
  var thisProgressStage = ProgressStage.OPENBRACKET;
  
  
  var operator = "";
  var identifier = "";
  var arguments = [];
  
  var currentArgument = 0;
  var numberOfArguments = 0;
  
  var numOpenBrack = 0;
  for (var i = 0, s = block.length; i<s; i++) {
    
    var c = block[i];
    
    console.log(c);
    console.log(thisProgressStage);
    
    var shouldExit = false;
    
    switch(thisProgressStage) {
      case ProgressStage.OPENBRACKET:
        if (c==" ") {
          continue;
        } else if (c!="(") {
          return processDefinition(block.substring(i));          
        } else {
          thisProgressStage = ProgressStage.OPERATOR;
        }
        break;
      case ProgressStage.OPERATOR:
        if (c==" ") {
          if (operator.length==0) {
            continue;
          } else {
            console.log("op"+operator);
            // Found operator
            if (operator=="define") {
              thisProgressStage = ProgressStage.IDENTIFIER;
              numberOfArguments = 1;
              thisBlockType = BlockType.DEFINE;
            } else if (builtInFuncBin.indexOf(operator) > -1) {
              thisBlockType = BlockType.BUILTINBIN;
              thisProgressStage = ProgressStage.ARGUMENT;
              numberOfArguments = 2;
            } else if (builtInFuncInf.indexOf(operator) > -1) {
              thisBlockType = BlockType.BUILTININF;
              thisProgressStage = ProgressStage.ARGUMENT;
              numberOfArguments = -1;
            }
            
          }
        } else {
          operator += c;
        }
        break;
      case ProgressStage.IDENTIFIER:
        if (c==" ") {
          if (identifier.length==0) {
            continue;
          } else {
            thisProgressStage = ProgressStage.ARGUMENT;
          }
        } else {
          identifier += c;
        }
        break;
      case ProgressStage.ARGUMENT:
        
        if (numberOfArguments==0) {
          thisProgressStage = ProgressStage.CLOSEBRACKET;
          break;
        } 
        
        if (arguments.length==currentArgument) {
          arguments[currentArgument]="";
        }
        
        if (c==" ") {
          if (arguments[currentArgument].length==0) {
            continue;
          } else if (numOpenBrack > 0) {
            arguments[currentArgument] += c;
          } else {
            console.log("currentarg" + arguments[currentArgument]);
            // TO DO: CHECK IF VALUE, IF NOT EVALUATE IT
            if (arguments[currentArgument][0] == "("){
              arguments[currentArgument] = process(arguments[currentArgument]);
            }
            currentArgument++;
            numberOfArguments--;
          }
        } else if (c == "(") {
            numOpenBrack++;
            arguments[currentArgument] += c;
        } else if (c==")") {
          if (numOpenBrack > 0){
            numOpenBrack--;
            arguments[currentArgument] += c;
          }else { 
            console.log(arguments[currentArgument]);
            if (arguments[currentArgument][0] == "("){
              arguments[currentArgument] = process(arguments[currentArgument]);
            }
            i--;
            thisProgressStage = ProgressStage.CLOSEBRACKET;
          }
        } else {
          arguments[currentArgument] += c;
        }
        
        
        break;
      case ProgressStage.CLOSEBRACKET:
        if (c==" ") {
          continue;
        } else if (c!=")") {
          throw "No CLOSE Bracket";
        } else {
          switch (thisBlockType){
            case BlockType.DEFINE:
              console.log("-"+ arguments[0]);
              definitions[identifier] = !isNaN(arguments[0]) ? arguments[0] : ((arguments[0].indexOf(".") > -1) ? parseFloat(arguments[0]) : parseInt(arguments[0]));
              shouldExit = true;
              break;
            case BlockType.BUILTINBIN:
              return processBuiltInBin(operator, arguments);
              break;
            case BlockType.BUILTININF:
              return processBuiltInInf(operator, arguments);
              break;
          }
        }
        break;
      default:
        break;
    }
    
    if (shouldExit) break;
  }
  
  
}
function processBuiltInBin(operator, arguments){
  if (operator == "remainder"){
    var a00 = parseInt(arguments[0]);
    var a10 = parseInt(arguments[1]);
    var a01 = parseFloat(arguments[0]);
    var a11 = parseFloat(arguments[1]);
    if (!isNaN(arguments[0]) && !isNaN(arguments[1]) && a00 == a01 && a10 == a11){
      if (a1 == 0){
        throw "Division By Zero";
      } else {
         return arguments[0]%arguments[1];
      }
    } else {
      throw "Invalid Arguments";
    }
    
  } else if (operator == "quotient"){
    var a00 = parseInt(arguments[0]);
    var a10 = parseInt(arguments[1]);
    var a01 = parseFloat(arguments[0]);
    var a11 = parseFloat(arguments[1]);
    if (!isNaN(arguments[0]) && !isNaN(arguments[1]) && a00 == a01 && a10 == a11){
      if (a1 == 0){
        throw "Division By Zero";
      } else {
         return Math.floor(arguments[0]/arguments[1]);
      }
    } else {
      throw "Invalid Arguments";
    }
  }
}
function processBuiltInInf(operator, arguments){

  if (operator == "+") {
    var base = 0;
    for (var i = 0; i < arguments.length; i++){
      var af = parseFloat(arguments[i]);
      if (!isNaN(arguments[i])){
        base += af;
      } else{
        throw "Invalid Argument Type";
      }
    }
    return base;
  }
  else if (operator == "-") {
    
    var base = 0;
    
    if (arguments.length==0) {
      throw "- expects at least 1 argument";
    } else if (arguments.length==1) {
      if (isNaN(arguments[0])) {
        throw "Not a number";
      }
      return -parseFloat(arguments[0]);
    }
    
    for (var i = 0; i < arguments.length; i++) {
      if (isNaN(arguments[i])) {
        throw "Not a number"
      }
      
      var ai = parseFloat(arguments[i]);
      
      if (i==0) {
        base = ai;
      } else {
        base -= ai;
      }
    }
    
    return base;
  }
  else if (operator == "*") {
    var base = 1;
    for (var i = 0; i < arguments.length; i++){
      var af = parseFloat(arguments[i]);
      if (!isNaN(arguments[i])){
        base *= af;
      } else{
        throw "Invalid Argument Type";
      }
    }
    return base;
  }
  else if (operator == "/") {
    
    var base = 1;
    
    
    if (arguments.length==0) {
      throw "/ expects at least 1 argument";
    }
    else if (arguments.length==1) {
      if (isNaN(arguments[0])) {
        throw "Not a number";
      } else if (parseFloat(arguments[0])==0) {
        throw "Division By Zero";
      }
      return base/parseFloat(arguments[0]);
    }
    
    for (var i = 0; i < arguments.length; i++) {
      if (isNaN(arguments[i])) {
        throw "Not a number"
      }
      
      var ai = parseFloat(arguments[i]);
      
      if (i==0) {
        base = ai;
      } else {
        if (ai==0) {
          throw "Division By Zero";
        }
        base = base/ai;
      }
    }
    
    return base;
  }
}
function processDefinition(block){
  var def ="";
  var seenBlank = false;
  for (var i = 0; i < block.length; i++){
    c = block[i];
    if (c == " ") seenBlank = true;
    else{
      if (seenBlank){
        throw "Syntax Error";
      }
      else{
        def += c;
      }
    }
  }
  if (def in definitions){
    return definitions[def];
  }
  else {
    throw "Undefined Variable";
  }
}

</script>

</body>
</html>
